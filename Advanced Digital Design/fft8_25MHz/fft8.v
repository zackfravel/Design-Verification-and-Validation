/*
 * This source file contains a Verilog description of a DFT IP core
 * automatically generated by the SPIRAL HDL Generator.
 *
 * This product includes a hardware design developed by Carnegie Mellon University.
 *
 * Copyright (c) 2010 by Peter A. Milder for the SPIRAL Project,
 * Carnegie Mellon University
 *
 * For more information, see the SPIRAL project website at:
 *   http://www.spiral.net
 *
 * This design is provided for internal, non-commercial research use only
 * and is not for redistribution, with or without modifications.
 * 
 * You may not use the name "Carnegie Mellon University" or derivations
 * thereof to endorse or promote products derived from this software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" WITHOUT ANY WARRANTY OF ANY KIND, EITHER
 * EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO ANY WARRANTY
 * THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS OR BE ERROR-FREE AND ANY
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
 * TITLE, OR NON-INFRINGEMENT.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * BE LIABLE FOR ANY DAMAGES, INCLUDING BUT NOT LIMITED TO DIRECT, INDIRECT,
 * SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM, OR IN
 * ANY WAY CONNECTED WITH THIS SOFTWARE (WHETHER OR NOT BASED UPON WARRANTY,
 * CONTRACT, TORT OR OTHERWISE).
 *
 */

//   Input/output stream: 2 complex words per cycle
//   Throughput: one transform every 32 cycles
//   Latency: 145 cycles

//   Resources required:
//     20 multipliers (8 x 8 bit)
//     34 adders (8 x 8 bit)
//     6 RAMs (64 words, 16 bits per word)
//     2 RAMs (32 words, 16 bits per word)
//     2 RAMs (8 words, 16 bits per word)
//     2 RAMs (16 words, 16 bits per word)
//     2 ROMs (8 words, 8 bits per word)
//     2 ROMs (32 words, 8 bits per word)
//     2 ROMs (16 words, 8 bits per word)

// Generated on Mon Sep 17 11:38:45 EDT 2012

// Latency: 145 clock cycles
// Throughput: 1 transform every 32 cycles


// We use an interleaved complex data format.  X0 represents the
// real portion of the first input, and X1 represents the imaginary
// portion.  The X variables are system inputs and the Y variables
// are system outputs.

// The design uses a system of flag signals to indicate the
// beginning of the input and output data streams.  The 'next'
// input (asserted high), is used to instruct the system that the
// input stream will begin on the following cycle.

// This system has a 'gap' of 32 cycles.  This means that
// 32 cycles must elapse between the beginning of the input
// vectors.

// The output signal 'next_out' (also asserted high) indicates
// that the output vector will begin streaming out of the system
 // on the following cycle.

// The system has a latency of 145 cycles.  This means that
// the 'next_out' will be asserted 145 cycles after the user
// asserts 'next'.

// The simple testbench below will demonstrate the timing for loading
// and unloading data vectors.
// The system reset signal is asserted high.

// Please note: when simulating floating point code, you must include
// Xilinx's DSP slice simulation module.


module fft8(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [7:0] t0_0;
   wire [7:0] t0_1;
   wire [7:0] t0_2;
   wire [7:0] t0_3;
   wire next_0;
   wire [7:0] t1_0;
   wire [7:0] t1_1;
   wire [7:0] t1_2;
   wire [7:0] t1_3;
   wire next_1;
   wire [7:0] t2_0;
   wire [7:0] t2_1;
   wire [7:0] t2_2;
   wire [7:0] t2_3;
   wire next_2;
   wire [7:0] t3_0;
   wire [7:0] t3_1;
   wire [7:0] t3_2;
   wire [7:0] t3_3;
   wire next_3;
   wire [7:0] t4_0;
   wire [7:0] t4_1;
   wire [7:0] t4_2;
   wire [7:0] t4_3;
   wire next_4;
   wire [7:0] t5_0;
   wire [7:0] t5_1;
   wire [7:0] t5_2;
   wire [7:0] t5_3;
   wire next_5;
   wire [7:0] t6_0;
   wire [7:0] t6_1;
   wire [7:0] t6_2;
   wire [7:0] t6_3;
   wire next_6;
   wire [7:0] t7_0;
   wire [7:0] t7_1;
   wire [7:0] t7_2;
   wire [7:0] t7_3;
   wire next_7;
   wire [7:0] t8_0;
   wire [7:0] t8_1;
   wire [7:0] t8_2;
   wire [7:0] t8_3;
   wire next_8;
   wire [7:0] t9_0;
   wire [7:0] t9_1;
   wire [7:0] t9_2;
   wire [7:0] t9_3;
   wire next_9;
   wire [7:0] t10_0;
   wire [7:0] t10_1;
   wire [7:0] t10_2;
   wire [7:0] t10_3;
   wire next_10;
   wire [7:0] t11_0;
   wire [7:0] t11_1;
   wire [7:0] t11_2;
   wire [7:0] t11_3;
   wire next_11;
   wire [7:0] t12_0;
   wire [7:0] t12_1;
   wire [7:0] t12_2;
   wire [7:0] t12_3;
   wire next_12;
   wire [7:0] t13_0;
   wire [7:0] t13_1;
   wire [7:0] t13_2;
   wire [7:0] t13_3;
   wire next_13;
   wire [7:0] t14_0;
   wire [7:0] t14_1;
   wire [7:0] t14_2;
   wire [7:0] t14_3;
   wire next_14;
   wire [7:0] t15_0;
   wire [7:0] t15_1;
   wire [7:0] t15_2;
   wire [7:0] t15_3;
   wire next_15;
   wire [7:0] t16_0;
   wire [7:0] t16_1;
   wire [7:0] t16_2;
   wire [7:0] t16_3;
   wire next_16;
   wire [7:0] t17_0;
   wire [7:0] t17_1;
   wire [7:0] t17_2;
   wire [7:0] t17_3;
   wire next_17;
   wire [7:0] t18_0;
   wire [7:0] t18_1;
   wire [7:0] t18_2;
   wire [7:0] t18_3;
   wire next_18;
   assign t0_0 = X0;
   assign Y0 = t18_0;
   assign t0_1 = X1;
   assign Y1 = t18_1;
   assign t0_2 = X2;
   assign Y2 = t18_2;
   assign t0_3 = X3;
   assign Y3 = t18_3;
   assign next_0 = next;
   assign next_out = next_18;

   rc14238 stage0(.clk(clk), .reset(reset), .next(next_0), .next_out(next_1),
    .X0(t0_0), .Y0(t1_0),
    .X1(t0_1), .Y1(t1_1),
    .X2(t0_2), .Y2(t1_2),
    .X3(t0_3), .Y3(t1_3));


   codeBlock14240 stage1(.clk(clk), .reset(reset), .next_in(next_1), .next_out(next_2),
       .X0_in(t1_0), .Y0(t2_0),
       .X1_in(t1_1), .Y1(t2_1),
       .X2_in(t1_2), .Y2(t2_2),
       .X3_in(t1_3), .Y3(t2_3));


   rc14319 stage2(.clk(clk), .reset(reset), .next(next_2), .next_out(next_3),
    .X0(t2_0), .Y0(t3_0),
    .X1(t2_1), .Y1(t3_1),
    .X2(t2_2), .Y2(t3_2),
    .X3(t2_3), .Y3(t3_3));


   DirSum_14494 stage3(.next(next_3), .clk(clk), .reset(reset), .next_out(next_4),
       .X0(t3_0), .Y0(t4_0),
       .X1(t3_1), .Y1(t4_1),
       .X2(t3_2), .Y2(t4_2),
       .X3(t3_3), .Y3(t4_3));


   codeBlock14497 stage4(.clk(clk), .reset(reset), .next_in(next_4), .next_out(next_5),
       .X0_in(t4_0), .Y0(t5_0),
       .X1_in(t4_1), .Y1(t5_1),
       .X2_in(t4_2), .Y2(t5_2),
       .X3_in(t4_3), .Y3(t5_3));


   rc14577 stage5(.clk(clk), .reset(reset), .next(next_5), .next_out(next_6),
    .X0(t5_0), .Y0(t6_0),
    .X1(t5_1), .Y1(t6_1),
    .X2(t5_2), .Y2(t6_2),
    .X3(t5_3), .Y3(t6_3));


   DirSum_14760 stage6(.next(next_6), .clk(clk), .reset(reset), .next_out(next_7),
       .X0(t6_0), .Y0(t7_0),
       .X1(t6_1), .Y1(t7_1),
       .X2(t6_2), .Y2(t7_2),
       .X3(t6_3), .Y3(t7_3));


   codeBlock14763 stage7(.clk(clk), .reset(reset), .next_in(next_7), .next_out(next_8),
       .X0_in(t7_0), .Y0(t8_0),
       .X1_in(t7_1), .Y1(t8_1),
       .X2_in(t7_2), .Y2(t8_2),
       .X3_in(t7_3), .Y3(t8_3));


   rc14843 stage8(.clk(clk), .reset(reset), .next(next_8), .next_out(next_9),
    .X0(t8_0), .Y0(t9_0),
    .X1(t8_1), .Y1(t9_1),
    .X2(t8_2), .Y2(t9_2),
    .X3(t8_3), .Y3(t9_3));


   DirSum_15042 stage9(.next(next_9), .clk(clk), .reset(reset), .next_out(next_10),
       .X0(t9_0), .Y0(t10_0),
       .X1(t9_1), .Y1(t10_1),
       .X2(t9_2), .Y2(t10_2),
       .X3(t9_3), .Y3(t10_3));


   codeBlock15045 stage10(.clk(clk), .reset(reset), .next_in(next_10), .next_out(next_11),
       .X0_in(t10_0), .Y0(t11_0),
       .X1_in(t10_1), .Y1(t11_1),
       .X2_in(t10_2), .Y2(t11_2),
       .X3_in(t10_3), .Y3(t11_3));


   rc15125 stage11(.clk(clk), .reset(reset), .next(next_11), .next_out(next_12),
    .X0(t11_0), .Y0(t12_0),
    .X1(t11_1), .Y1(t12_1),
    .X2(t11_2), .Y2(t12_2),
    .X3(t11_3), .Y3(t12_3));


   DirSum_15356 stage12(.next(next_12), .clk(clk), .reset(reset), .next_out(next_13),
       .X0(t12_0), .Y0(t13_0),
       .X1(t12_1), .Y1(t13_1),
       .X2(t12_2), .Y2(t13_2),
       .X3(t12_3), .Y3(t13_3));


   codeBlock15359 stage13(.clk(clk), .reset(reset), .next_in(next_13), .next_out(next_14),
       .X0_in(t13_0), .Y0(t14_0),
       .X1_in(t13_1), .Y1(t14_1),
       .X2_in(t13_2), .Y2(t14_2),
       .X3_in(t13_3), .Y3(t14_3));


   rc15439 stage14(.clk(clk), .reset(reset), .next(next_14), .next_out(next_15),
    .X0(t14_0), .Y0(t15_0),
    .X1(t14_1), .Y1(t15_1),
    .X2(t14_2), .Y2(t15_2),
    .X3(t14_3), .Y3(t15_3));


   DirSum_15733 stage15(.next(next_15), .clk(clk), .reset(reset), .next_out(next_16),
       .X0(t15_0), .Y0(t16_0),
       .X1(t15_1), .Y1(t16_1),
       .X2(t15_2), .Y2(t16_2),
       .X3(t15_3), .Y3(t16_3));


   codeBlock15736 stage16(.clk(clk), .reset(reset), .next_in(next_16), .next_out(next_17),
       .X0_in(t16_0), .Y0(t17_0),
       .X1_in(t16_1), .Y1(t17_1),
       .X2_in(t16_2), .Y2(t17_2),
       .X3_in(t16_3), .Y3(t17_3));


   rc15816 stage17(.clk(clk), .reset(reset), .next(next_17), .next_out(next_18),
    .X0(t17_0), .Y0(t18_0),
    .X1(t17_1), .Y1(t18_1),
    .X2(t17_2), .Y2(t18_2),
    .X3(t17_3), .Y3(t18_3));


endmodule

module rc14238(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [15:0] t0;
   wire [15:0] s0;
   assign t0 = {X0, X1};
   wire [15:0] t1;
   wire [15:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[15:8];
   assign Y1 = s0[7:0];
   assign Y2 = s1[15:8];
   assign Y3 = s1[7:0];

   perm14236 instPerm16649(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module perm14236(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 32;
   parameter logDepth = 5;
   parameter width = 16;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[5] ^ addr0[0];
   assign inAddr0[0] = addr0[4];
   assign inAddr0[1] = addr0[3];
   assign inAddr0[2] = addr0[2];
   assign inAddr0[3] = addr0[1];
   assign inAddr0[4] = addr0[0];
   assign outBank0[0] = addr0b[5] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outAddr0[2] = addr0b[3];
   assign outAddr0[3] = addr0b[4];
   assign outAddr0[4] = addr0b[5];
   assign outBank_a0[0] = addr0c[5] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];
   assign outAddr_a0[2] = addr0c[3];
   assign outAddr_a0[3] = addr0c[4];
   assign outAddr_a0[4] = addr0c[5];

   assign inBank1[0] = addr1[5] ^ addr1[0];
   assign inAddr1[0] = addr1[4];
   assign inAddr1[1] = addr1[3];
   assign inAddr1[2] = addr1[2];
   assign inAddr1[3] = addr1[1];
   assign inAddr1[4] = addr1[0];
   assign outBank1[0] = addr1b[5] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outAddr1[2] = addr1b[3];
   assign outAddr1[3] = addr1b[4];
   assign outAddr1[4] = addr1b[5];
   assign outBank_a1[0] = addr1c[5] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];
   assign outAddr_a1[2] = addr1c[3];
   assign outAddr_a1[3] = addr1c[4];
   assign outAddr_a1[4] = addr1c[5];

   nextReg #(26, 5) nextReg_16654(.X(next), .Y(next0), .reset(reset), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_16657(.X(next0), .Y(next_out), .clk(clk));


   memArray64_14236 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 25)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 27)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 25) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 31) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 25)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[4];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[4];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[4];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray64_14236(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 32;
   parameter logDepth = 5;
   parameter width = 16;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   nextReg #(32, 5) nextReg_16662(.X(next), .Y(next0), .reset(reset), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

module nextReg(X, Y, reset, clk);
   parameter depth=2, logDepth=1;

   output Y;
   input X;
   input              clk, reset;
   reg [logDepth:0] count;
   reg                active;

   assign Y = (count == depth) ? 1 : 0;

   always @ (posedge clk) begin
      if (reset == 1) begin
         count <= 0;
         active <= 0;
      end
      else if (X == 1) begin
         active <= 1;
         count <= 1;
      end
      else if (count == depth) begin
         count <= 0;
         active <= 0;
      end
      else if (active)
         count <= count+1;
   end
endmodule


module memMod(in, out, inAddr, outAddr, writeSel, clk);
   
   parameter depth=1024, width=16, logDepth=10;
   
   input [width-1:0]    in;
   input [logDepth-1:0] inAddr, outAddr;
   input 	        writeSel, clk;
   output [width-1:0] 	out;
   reg [width-1:0] 	out;
   
   // synthesis attribute ram_style of mem is block

   reg [width-1:0] 	mem[depth-1:0]; 
   
   always @(posedge clk) begin
      out <= mem[outAddr];
      
      if (writeSel)
        mem[inAddr] <= in;
   end
endmodule 



module memMod_dist(in, out, inAddr, outAddr, writeSel, clk);
   
   parameter depth=1024, width=16, logDepth=10;
   
   input [width-1:0]    in;
   input [logDepth-1:0] inAddr, outAddr;
   input 	        writeSel, clk;
   output [width-1:0] 	out;
   reg [width-1:0] 	out;
   
   // synthesis attribute ram_style of mem is distributed

   reg [width-1:0] 	mem[depth-1:0]; 
   
   always @(posedge clk) begin
      out <= mem[outAddr];
      
      if (writeSel)
        mem[inAddr] <= in;
   end
endmodule 

module switch(ctrl, x0, x1, y0, y1);
    parameter width = 16;
    input [width-1:0] x0, x1;
    output [width-1:0] y0, y1;
    input ctrl;
    assign y0 = (ctrl == 0) ? x0 : x1;
    assign y1 = (ctrl == 0) ? x1 : x0;
endmodule

module shiftRegFIFO(X, Y, clk);
   parameter depth=1, width=1;

   output [width-1:0] Y;
   input  [width-1:0] X;
   input              clk;

   reg [width-1:0]    mem [depth-1:0];
   integer            index;

   assign Y = mem[depth-1];

   always @ (posedge clk) begin
      for(index=1;index<depth;index=index+1) begin
         mem[index] <= mem[index-1];
      end
      mem[0]<=X;
   end
endmodule

module codeBlock14240(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [7:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_16669(.X(next), .Y(next_out), .clk(clk));


   wire signed [7:0] a309;
   wire signed [7:0] a310;
   wire signed [7:0] t141;
   wire signed [7:0] a311;
   wire signed [7:0] a312;
   wire signed [7:0] t142;
   wire signed [7:0] t143;
   wire signed [7:0] t144;
   wire signed [7:0] Y0;
   wire signed [7:0] Y1;
   wire signed [7:0] Y2;
   wire signed [7:0] Y3;


   assign a309 = X0;
   assign a310 = X2;
   assign a311 = X1;
   assign a312 = X3;
   assign Y0 = t141;
   assign Y1 = t142;
   assign Y2 = t143;
   assign Y3 = t144;

    addfxp #(8, 1) add14252(.a(a309), .b(a310), .clk(clk), .q(t141));
    addfxp #(8, 1) add14267(.a(a311), .b(a312), .clk(clk), .q(t142));
    subfxp #(8, 1) sub14281(.a(a309), .b(a310), .clk(clk), .q(t143));
    subfxp #(8, 1) sub14295(.a(a311), .b(a312), .clk(clk), .q(t144));
   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

module rc14319(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [15:0] t0;
   wire [15:0] s0;
   assign t0 = {X0, X1};
   wire [15:0] t1;
   wire [15:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[15:8];
   assign Y1 = s0[7:0];
   assign Y2 = s1[15:8];
   assign Y3 = s1[7:0];

   perm14317 instPerm16670(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module perm14317(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 2;
   parameter logDepth = 1;
   parameter width = 16;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[1] ^ addr0[0];
   assign inAddr0[0] = addr0[0];
   assign outBank0[0] = addr0b[1] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outBank_a0[0] = addr0c[1] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];

   assign inBank1[0] = addr1[1] ^ addr1[0];
   assign inAddr1[0] = addr1[0];
   assign outBank1[0] = addr1b[1] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outBank_a1[0] = addr1c[1] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];

   shiftRegFIFO #(2, 1) shiftFIFO_16673(.X(next), .Y(next0), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_16676(.X(next0), .Y(next_out), .clk(clk));


   memArray4_14317 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

    reg resetOutCountRd2_2;
    reg resetOutCountRd2_3;

    always @(posedge clk) begin
        if (reset == 1) begin
            resetOutCountRd2_2 <= 0;
            resetOutCountRd2_3 <= 0;
        end
        else begin
            resetOutCountRd2_2 <= (inCount == 1) ? 1'b1 : 1'b0;
            resetOutCountRd2_3 <= resetOutCountRd2_2;
            if (resetOutCountRd2_3 == 1'b1)
                outCount_for_rd_data <= 0;
            else
                outCount_for_rd_data <= outCount_for_rd_data+1;
        end
    end
   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 1)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 1) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 1) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 1)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[0];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[0];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[0];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray4_14317(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 2;
   parameter logDepth = 1;
   parameter width = 16;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   shiftRegFIFO #(2, 1) shiftFIFO_16679(.X(next), .Y(next0), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

module DirSum_14494(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [0:0] i8;

   input [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i8 <= 0;
      end
      else begin
         if (next == 1)
            i8 <= 0;
         else if (i8 == 1)
            i8 <= 0;
         else
            i8 <= i8 + 1;
      end
   end

   codeBlock14322 codeBlockIsnt16680(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i8_in(i8),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D18(addr, out, clk);
   input clk;
   output [7:0] out;
   reg [7:0] out, out2, out3;
   input [0:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 8'h40;
      1: out3 <= 8'h0;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D20(addr, out, clk);
   input clk;
   output [7:0] out;
   reg [7:0] out, out2, out3;
   input [0:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 8'h0;
      1: out3 <= 8'hc0;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module codeBlock14322(clk, reset, next_in, next_out,
   i8_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [0:0] i8_in;
   reg [0:0] i8;

   input [7:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(7, 1) shiftFIFO_16683(.X(next), .Y(next_out), .clk(clk));


   wire signed [7:0] a293;
   wire signed [7:0] a282;
   wire signed [7:0] Y0;
   wire signed [7:0] a296;
   wire signed [7:0] a286;
   wire signed [7:0] Y1;
   wire signed [7:0] tm2;
   wire signed [7:0] a287;
   wire signed [7:0] a297;
   wire signed [7:0] a288;
   wire signed [7:0] tm3;
   wire signed [7:0] a289;
   wire signed [7:0] a298;
   wire signed [7:0] a290;
   wire signed [7:0] Y2;
   wire signed [7:0] a291;
   wire signed [7:0] a292;
   wire signed [7:0] Y3;
   reg signed [7:0] tm24;
   reg signed [7:0] tm25;
   reg signed [7:0] tm130;
   reg signed [7:0] tm131;
   reg signed [7:0] tm132;
   reg signed [7:0] tm133;
   reg signed [7:0] tm134;
   reg signed [7:0] tm135;
   reg signed [7:0] tm136;
   reg signed [7:0] tm137;
   reg signed [7:0] tm146;
   reg signed [7:0] tm147;
   reg signed [7:0] tm148;
   reg signed [7:0] tm149;
   reg signed [7:0] tm150;
   reg signed [7:0] tm151;
   reg signed [7:0] tm152;
   reg signed [7:0] tm153;
   reg signed [7:0] tm154;
   reg signed [7:0] tm155;
   reg signed [7:0] tm156;
   reg signed [7:0] tm157;
   reg signed [7:0] tm158;
   reg signed [7:0] tm159;


   assign a293 = X0;
   assign a282 = a293;
   assign Y0 = tm152;
   assign a296 = X1;
   assign a286 = a296;
   assign Y1 = tm159;
   assign a287 = tm2;
   assign a297 = X2;
   assign a289 = tm3;
   assign a298 = X3;

   D18 instD18inst0(.addr(i8[0:0]), .out(tm2), .clk(clk));

   D20 instD20inst0(.addr(i8[0:0]), .out(tm3), .clk(clk));

    multfix #(8, 2) m14420(.a(tm24), .b(tm133), .clk(clk), .q_sc(a288), .q_unsc(), .rst(reset));
    multfix #(8, 2) m14442(.a(tm25), .b(tm137), .clk(clk), .q_sc(a290), .q_unsc(), .rst(reset));
    subfxp #(8, 1) sub14448(.a(a288), .b(a290), .clk(clk), .q(Y2));
    multfix #(8, 2) m14459(.a(tm25), .b(tm133), .clk(clk), .q_sc(a291), .q_unsc(), .rst(reset));
    multfix #(8, 2) m14470(.a(tm24), .b(tm137), .clk(clk), .q_sc(a292), .q_unsc(), .rst(reset));
    addfxp #(8, 1) add14477(.a(a291), .b(a292), .clk(clk), .q(Y3));
   always @(posedge clk) begin
      if (reset == 1) begin
         tm24 <= 0;
         tm133 <= 0;
         tm25 <= 0;
         tm137 <= 0;
         tm25 <= 0;
         tm133 <= 0;
         tm24 <= 0;
         tm137 <= 0;
      end
      else begin
         i8 <= i8_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm24 <= a287;
         tm25 <= a289;
         tm130 <= a297;
         tm131 <= tm130;
         tm132 <= tm131;
         tm133 <= tm132;
         tm134 <= a298;
         tm135 <= tm134;
         tm136 <= tm135;
         tm137 <= tm136;
         tm146 <= a282;
         tm147 <= tm146;
         tm148 <= tm147;
         tm149 <= tm148;
         tm150 <= tm149;
         tm151 <= tm150;
         tm152 <= tm151;
         tm153 <= a286;
         tm154 <= tm153;
         tm155 <= tm154;
         tm156 <= tm155;
         tm157 <= tm156;
         tm158 <= tm157;
         tm159 <= tm158;
      end
   end
endmodule

module codeBlock14497(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [7:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_16686(.X(next), .Y(next_out), .clk(clk));


   wire signed [7:0] a249;
   wire signed [7:0] a250;
   wire signed [7:0] t117;
   wire signed [7:0] a251;
   wire signed [7:0] a252;
   wire signed [7:0] t118;
   wire signed [7:0] t119;
   wire signed [7:0] t120;
   wire signed [7:0] Y0;
   wire signed [7:0] Y1;
   wire signed [7:0] Y2;
   wire signed [7:0] Y3;


   assign a249 = X0;
   assign a250 = X2;
   assign a251 = X1;
   assign a252 = X3;
   assign Y0 = t117;
   assign Y1 = t118;
   assign Y2 = t119;
   assign Y3 = t120;

    addfxp #(8, 1) add14509(.a(a249), .b(a250), .clk(clk), .q(t117));
    addfxp #(8, 1) add14524(.a(a251), .b(a252), .clk(clk), .q(t118));
    subfxp #(8, 1) sub14538(.a(a249), .b(a250), .clk(clk), .q(t119));
    subfxp #(8, 1) sub14552(.a(a251), .b(a252), .clk(clk), .q(t120));
   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

module rc14577(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [15:0] t0;
   wire [15:0] s0;
   assign t0 = {X0, X1};
   wire [15:0] t1;
   wire [15:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[15:8];
   assign Y1 = s0[7:0];
   assign Y2 = s1[15:8];
   assign Y3 = s1[7:0];

   perm14575 instPerm16687(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module perm14575(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 4;
   parameter logDepth = 2;
   parameter width = 16;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[2] ^ addr0[0];
   assign inAddr0[0] = addr0[1];
   assign inAddr0[1] = addr0[0];
   assign outBank0[0] = addr0b[2] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outBank_a0[0] = addr0c[2] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];

   assign inBank1[0] = addr1[2] ^ addr1[0];
   assign inAddr1[0] = addr1[1];
   assign inAddr1[1] = addr1[0];
   assign outBank1[0] = addr1b[2] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outBank_a1[0] = addr1c[2] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];

   shiftRegFIFO #(3, 1) shiftFIFO_16690(.X(next), .Y(next0), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_16693(.X(next0), .Y(next_out), .clk(clk));


   memArray8_14575 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

    reg resetOutCountRd2_4;

    always @(posedge clk) begin
        if (reset == 1) begin
            resetOutCountRd2_4 <= 0;
        end
        else begin
            resetOutCountRd2_4 <= (inCount == 3) ? 1'b1 : 1'b0;
            if (resetOutCountRd2_4 == 1'b1)
                outCount_for_rd_data <= 0;
            else
                outCount_for_rd_data <= outCount_for_rd_data+1;
        end
    end
   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 2)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 2) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 3) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 2)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[1];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[1];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[1];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray8_14575(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 4;
   parameter logDepth = 2;
   parameter width = 16;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   shiftRegFIFO #(4, 1) shiftFIFO_16696(.X(next), .Y(next0), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

module DirSum_14760(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [1:0] i7;

   input [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i7 <= 0;
      end
      else begin
         if (next == 1)
            i7 <= 0;
         else if (i7 == 3)
            i7 <= 0;
         else
            i7 <= i7 + 1;
      end
   end

   codeBlock14580 codeBlockIsnt16697(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i7_in(i7),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D14(addr, out, clk);
   input clk;
   output [7:0] out;
   reg [7:0] out, out2, out3;
   input [1:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 8'h40;
      1: out3 <= 8'h2d;
      2: out3 <= 8'h0;
      3: out3 <= 8'hd3;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D16(addr, out, clk);
   input clk;
   output [7:0] out;
   reg [7:0] out, out2, out3;
   input [1:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 8'h0;
      1: out3 <= 8'hd3;
      2: out3 <= 8'hc0;
      3: out3 <= 8'hd3;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module codeBlock14580(clk, reset, next_in, next_out,
   i7_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [1:0] i7_in;
   reg [1:0] i7;

   input [7:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(7, 1) shiftFIFO_16700(.X(next), .Y(next_out), .clk(clk));


   wire signed [7:0] a233;
   wire signed [7:0] a222;
   wire signed [7:0] Y0;
   wire signed [7:0] a236;
   wire signed [7:0] a226;
   wire signed [7:0] Y1;
   wire signed [7:0] tm6;
   wire signed [7:0] a227;
   wire signed [7:0] a237;
   wire signed [7:0] a228;
   wire signed [7:0] tm7;
   wire signed [7:0] a229;
   wire signed [7:0] a238;
   wire signed [7:0] a230;
   wire signed [7:0] Y2;
   wire signed [7:0] a231;
   wire signed [7:0] a232;
   wire signed [7:0] Y3;
   reg signed [7:0] tm32;
   reg signed [7:0] tm33;
   reg signed [7:0] tm160;
   reg signed [7:0] tm161;
   reg signed [7:0] tm162;
   reg signed [7:0] tm163;
   reg signed [7:0] tm164;
   reg signed [7:0] tm165;
   reg signed [7:0] tm166;
   reg signed [7:0] tm167;
   reg signed [7:0] tm176;
   reg signed [7:0] tm177;
   reg signed [7:0] tm178;
   reg signed [7:0] tm179;
   reg signed [7:0] tm180;
   reg signed [7:0] tm181;
   reg signed [7:0] tm182;
   reg signed [7:0] tm183;
   reg signed [7:0] tm184;
   reg signed [7:0] tm185;
   reg signed [7:0] tm186;
   reg signed [7:0] tm187;
   reg signed [7:0] tm188;
   reg signed [7:0] tm189;


   assign a233 = X0;
   assign a222 = a233;
   assign Y0 = tm182;
   assign a236 = X1;
   assign a226 = a236;
   assign Y1 = tm189;
   assign a227 = tm6;
   assign a237 = X2;
   assign a229 = tm7;
   assign a238 = X3;

   D14 instD14inst0(.addr(i7[1:0]), .out(tm6), .clk(clk));

   D16 instD16inst0(.addr(i7[1:0]), .out(tm7), .clk(clk));

    multfix #(8, 2) m14678(.a(tm32), .b(tm163), .clk(clk), .q_sc(a228), .q_unsc(), .rst(reset));
    multfix #(8, 2) m14700(.a(tm33), .b(tm167), .clk(clk), .q_sc(a230), .q_unsc(), .rst(reset));
    subfxp #(8, 1) sub14706(.a(a228), .b(a230), .clk(clk), .q(Y2));
    multfix #(8, 2) m14717(.a(tm33), .b(tm163), .clk(clk), .q_sc(a231), .q_unsc(), .rst(reset));
    multfix #(8, 2) m14728(.a(tm32), .b(tm167), .clk(clk), .q_sc(a232), .q_unsc(), .rst(reset));
    addfxp #(8, 1) add14735(.a(a231), .b(a232), .clk(clk), .q(Y3));
   always @(posedge clk) begin
      if (reset == 1) begin
         tm32 <= 0;
         tm163 <= 0;
         tm33 <= 0;
         tm167 <= 0;
         tm33 <= 0;
         tm163 <= 0;
         tm32 <= 0;
         tm167 <= 0;
      end
      else begin
         i7 <= i7_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm32 <= a227;
         tm33 <= a229;
         tm160 <= a237;
         tm161 <= tm160;
         tm162 <= tm161;
         tm163 <= tm162;
         tm164 <= a238;
         tm165 <= tm164;
         tm166 <= tm165;
         tm167 <= tm166;
         tm176 <= a222;
         tm177 <= tm176;
         tm178 <= tm177;
         tm179 <= tm178;
         tm180 <= tm179;
         tm181 <= tm180;
         tm182 <= tm181;
         tm183 <= a226;
         tm184 <= tm183;
         tm185 <= tm184;
         tm186 <= tm185;
         tm187 <= tm186;
         tm188 <= tm187;
         tm189 <= tm188;
      end
   end
endmodule

module codeBlock14763(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [7:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_16703(.X(next), .Y(next_out), .clk(clk));


   wire signed [7:0] a189;
   wire signed [7:0] a190;
   wire signed [7:0] t93;
   wire signed [7:0] a191;
   wire signed [7:0] a192;
   wire signed [7:0] t94;
   wire signed [7:0] t95;
   wire signed [7:0] t96;
   wire signed [7:0] Y0;
   wire signed [7:0] Y1;
   wire signed [7:0] Y2;
   wire signed [7:0] Y3;


   assign a189 = X0;
   assign a190 = X2;
   assign a191 = X1;
   assign a192 = X3;
   assign Y0 = t93;
   assign Y1 = t94;
   assign Y2 = t95;
   assign Y3 = t96;

    addfxp #(8, 1) add14775(.a(a189), .b(a190), .clk(clk), .q(t93));
    addfxp #(8, 1) add14790(.a(a191), .b(a192), .clk(clk), .q(t94));
    subfxp #(8, 1) sub14804(.a(a189), .b(a190), .clk(clk), .q(t95));
    subfxp #(8, 1) sub14818(.a(a191), .b(a192), .clk(clk), .q(t96));
   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

module rc14843(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [15:0] t0;
   wire [15:0] s0;
   assign t0 = {X0, X1};
   wire [15:0] t1;
   wire [15:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[15:8];
   assign Y1 = s0[7:0];
   assign Y2 = s1[15:8];
   assign Y3 = s1[7:0];

   perm14841 instPerm16704(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module perm14841(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 8;
   parameter logDepth = 3;
   parameter width = 16;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[3] ^ addr0[0];
   assign inAddr0[0] = addr0[1];
   assign inAddr0[1] = addr0[2];
   assign inAddr0[2] = addr0[0];
   assign outBank0[0] = addr0b[3] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outAddr0[2] = addr0b[3];
   assign outBank_a0[0] = addr0c[3] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];
   assign outAddr_a0[2] = addr0c[3];

   assign inBank1[0] = addr1[3] ^ addr1[0];
   assign inAddr1[0] = addr1[1];
   assign inAddr1[1] = addr1[2];
   assign inAddr1[2] = addr1[0];
   assign outBank1[0] = addr1b[3] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outAddr1[2] = addr1b[3];
   assign outBank_a1[0] = addr1c[3] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];
   assign outAddr_a1[2] = addr1c[3];

   shiftRegFIFO #(5, 1) shiftFIFO_16707(.X(next), .Y(next0), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_16710(.X(next0), .Y(next_out), .clk(clk));


   memArray16_14841 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 4)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 6)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 4) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 7) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 4)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[2];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[2];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[2];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray16_14841(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 8;
   parameter logDepth = 3;
   parameter width = 16;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   shiftRegFIFO #(8, 1) shiftFIFO_16713(.X(next), .Y(next0), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

module DirSum_15042(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [2:0] i6;

   input [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i6 <= 0;
      end
      else begin
         if (next == 1)
            i6 <= 0;
         else if (i6 == 7)
            i6 <= 0;
         else
            i6 <= i6 + 1;
      end
   end

   codeBlock14846 codeBlockIsnt16714(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i6_in(i6),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D10(addr, out, clk);
   input clk;
   output [7:0] out;
   reg [7:0] out, out2, out3;
   input [2:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 8'h40;
      1: out3 <= 8'h3b;
      2: out3 <= 8'h2d;
      3: out3 <= 8'h18;
      4: out3 <= 8'h0;
      5: out3 <= 8'he8;
      6: out3 <= 8'hd3;
      7: out3 <= 8'hc5;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D12(addr, out, clk);
   input clk;
   output [7:0] out;
   reg [7:0] out, out2, out3;
   input [2:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 8'h0;
      1: out3 <= 8'he8;
      2: out3 <= 8'hd3;
      3: out3 <= 8'hc5;
      4: out3 <= 8'hc0;
      5: out3 <= 8'hc5;
      6: out3 <= 8'hd3;
      7: out3 <= 8'he8;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module codeBlock14846(clk, reset, next_in, next_out,
   i6_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [2:0] i6_in;
   reg [2:0] i6;

   input [7:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(7, 1) shiftFIFO_16717(.X(next), .Y(next_out), .clk(clk));


   wire signed [7:0] a173;
   wire signed [7:0] a162;
   wire signed [7:0] Y0;
   wire signed [7:0] a176;
   wire signed [7:0] a166;
   wire signed [7:0] Y1;
   wire signed [7:0] tm10;
   wire signed [7:0] a167;
   wire signed [7:0] a177;
   wire signed [7:0] a168;
   wire signed [7:0] tm11;
   wire signed [7:0] a169;
   wire signed [7:0] a178;
   wire signed [7:0] a170;
   wire signed [7:0] Y2;
   wire signed [7:0] a171;
   wire signed [7:0] a172;
   wire signed [7:0] Y3;
   reg signed [7:0] tm40;
   reg signed [7:0] tm41;
   reg signed [7:0] tm190;
   reg signed [7:0] tm191;
   reg signed [7:0] tm192;
   reg signed [7:0] tm193;
   reg signed [7:0] tm194;
   reg signed [7:0] tm195;
   reg signed [7:0] tm196;
   reg signed [7:0] tm197;
   reg signed [7:0] tm206;
   reg signed [7:0] tm207;
   reg signed [7:0] tm208;
   reg signed [7:0] tm209;
   reg signed [7:0] tm210;
   reg signed [7:0] tm211;
   reg signed [7:0] tm212;
   reg signed [7:0] tm213;
   reg signed [7:0] tm214;
   reg signed [7:0] tm215;
   reg signed [7:0] tm216;
   reg signed [7:0] tm217;
   reg signed [7:0] tm218;
   reg signed [7:0] tm219;


   assign a173 = X0;
   assign a162 = a173;
   assign Y0 = tm212;
   assign a176 = X1;
   assign a166 = a176;
   assign Y1 = tm219;
   assign a167 = tm10;
   assign a177 = X2;
   assign a169 = tm11;
   assign a178 = X3;

   D10 instD10inst0(.addr(i6[2:0]), .out(tm10), .clk(clk));

   D12 instD12inst0(.addr(i6[2:0]), .out(tm11), .clk(clk));

    multfix #(8, 2) m14944(.a(tm40), .b(tm193), .clk(clk), .q_sc(a168), .q_unsc(), .rst(reset));
    multfix #(8, 2) m14966(.a(tm41), .b(tm197), .clk(clk), .q_sc(a170), .q_unsc(), .rst(reset));
    subfxp #(8, 1) sub14972(.a(a168), .b(a170), .clk(clk), .q(Y2));
    multfix #(8, 2) m14983(.a(tm41), .b(tm193), .clk(clk), .q_sc(a171), .q_unsc(), .rst(reset));
    multfix #(8, 2) m14994(.a(tm40), .b(tm197), .clk(clk), .q_sc(a172), .q_unsc(), .rst(reset));
    addfxp #(8, 1) add15001(.a(a171), .b(a172), .clk(clk), .q(Y3));
   always @(posedge clk) begin
      if (reset == 1) begin
         tm40 <= 0;
         tm193 <= 0;
         tm41 <= 0;
         tm197 <= 0;
         tm41 <= 0;
         tm193 <= 0;
         tm40 <= 0;
         tm197 <= 0;
      end
      else begin
         i6 <= i6_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm40 <= a167;
         tm41 <= a169;
         tm190 <= a177;
         tm191 <= tm190;
         tm192 <= tm191;
         tm193 <= tm192;
         tm194 <= a178;
         tm195 <= tm194;
         tm196 <= tm195;
         tm197 <= tm196;
         tm206 <= a162;
         tm207 <= tm206;
         tm208 <= tm207;
         tm209 <= tm208;
         tm210 <= tm209;
         tm211 <= tm210;
         tm212 <= tm211;
         tm213 <= a166;
         tm214 <= tm213;
         tm215 <= tm214;
         tm216 <= tm215;
         tm217 <= tm216;
         tm218 <= tm217;
         tm219 <= tm218;
      end
   end
endmodule

module codeBlock15045(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [7:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_16720(.X(next), .Y(next_out), .clk(clk));


   wire signed [7:0] a129;
   wire signed [7:0] a130;
   wire signed [7:0] t69;
   wire signed [7:0] a131;
   wire signed [7:0] a132;
   wire signed [7:0] t70;
   wire signed [7:0] t71;
   wire signed [7:0] t72;
   wire signed [7:0] Y0;
   wire signed [7:0] Y1;
   wire signed [7:0] Y2;
   wire signed [7:0] Y3;


   assign a129 = X0;
   assign a130 = X2;
   assign a131 = X1;
   assign a132 = X3;
   assign Y0 = t69;
   assign Y1 = t70;
   assign Y2 = t71;
   assign Y3 = t72;

    addfxp #(8, 1) add15057(.a(a129), .b(a130), .clk(clk), .q(t69));
    addfxp #(8, 1) add15072(.a(a131), .b(a132), .clk(clk), .q(t70));
    subfxp #(8, 1) sub15086(.a(a129), .b(a130), .clk(clk), .q(t71));
    subfxp #(8, 1) sub15100(.a(a131), .b(a132), .clk(clk), .q(t72));
   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

module rc15125(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [15:0] t0;
   wire [15:0] s0;
   assign t0 = {X0, X1};
   wire [15:0] t1;
   wire [15:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[15:8];
   assign Y1 = s0[7:0];
   assign Y2 = s1[15:8];
   assign Y3 = s1[7:0];

   perm15123 instPerm16721(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module perm15123(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 16;
   parameter logDepth = 4;
   parameter width = 16;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[4] ^ addr0[0];
   assign inAddr0[0] = addr0[1];
   assign inAddr0[1] = addr0[2];
   assign inAddr0[2] = addr0[3];
   assign inAddr0[3] = addr0[0];
   assign outBank0[0] = addr0b[4] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outAddr0[2] = addr0b[3];
   assign outAddr0[3] = addr0b[4];
   assign outBank_a0[0] = addr0c[4] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];
   assign outAddr_a0[2] = addr0c[3];
   assign outAddr_a0[3] = addr0c[4];

   assign inBank1[0] = addr1[4] ^ addr1[0];
   assign inAddr1[0] = addr1[1];
   assign inAddr1[1] = addr1[2];
   assign inAddr1[2] = addr1[3];
   assign inAddr1[3] = addr1[0];
   assign outBank1[0] = addr1b[4] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outAddr1[2] = addr1b[3];
   assign outAddr1[3] = addr1b[4];
   assign outBank_a1[0] = addr1c[4] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];
   assign outAddr_a1[2] = addr1c[3];
   assign outAddr_a1[3] = addr1c[4];

   nextReg #(9, 4) nextReg_16726(.X(next), .Y(next0), .reset(reset), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_16729(.X(next0), .Y(next_out), .clk(clk));


   memArray32_15123 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 8)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 10)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 8) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 15) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 8)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[3];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[3];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[3];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray32_15123(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 16;
   parameter logDepth = 4;
   parameter width = 16;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   nextReg #(16, 4) nextReg_16734(.X(next), .Y(next0), .reset(reset), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

module DirSum_15356(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [3:0] i5;

   input [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i5 <= 0;
      end
      else begin
         if (next == 1)
            i5 <= 0;
         else if (i5 == 15)
            i5 <= 0;
         else
            i5 <= i5 + 1;
      end
   end

   codeBlock15128 codeBlockIsnt16739(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i5_in(i5),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D6(addr, out, clk);
   input clk;
   output [7:0] out;
   reg [7:0] out, out2, out3;
   input [3:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 8'h40;
      1: out3 <= 8'h3f;
      2: out3 <= 8'h3b;
      3: out3 <= 8'h35;
      4: out3 <= 8'h2d;
      5: out3 <= 8'h24;
      6: out3 <= 8'h18;
      7: out3 <= 8'hc;
      8: out3 <= 8'h0;
      9: out3 <= 8'hf4;
      10: out3 <= 8'he8;
      11: out3 <= 8'hdc;
      12: out3 <= 8'hd3;
      13: out3 <= 8'hcb;
      14: out3 <= 8'hc5;
      15: out3 <= 8'hc1;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D8(addr, out, clk);
   input clk;
   output [7:0] out;
   reg [7:0] out, out2, out3;
   input [3:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 8'h0;
      1: out3 <= 8'hf4;
      2: out3 <= 8'he8;
      3: out3 <= 8'hdc;
      4: out3 <= 8'hd3;
      5: out3 <= 8'hcb;
      6: out3 <= 8'hc5;
      7: out3 <= 8'hc1;
      8: out3 <= 8'hc0;
      9: out3 <= 8'hc1;
      10: out3 <= 8'hc5;
      11: out3 <= 8'hcb;
      12: out3 <= 8'hd3;
      13: out3 <= 8'hdc;
      14: out3 <= 8'he8;
      15: out3 <= 8'hf4;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module codeBlock15128(clk, reset, next_in, next_out,
   i5_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [3:0] i5_in;
   reg [3:0] i5;

   input [7:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(7, 1) shiftFIFO_16742(.X(next), .Y(next_out), .clk(clk));


   wire signed [7:0] a113;
   wire signed [7:0] a102;
   wire signed [7:0] Y0;
   wire signed [7:0] a116;
   wire signed [7:0] a106;
   wire signed [7:0] Y1;
   wire signed [7:0] tm14;
   wire signed [7:0] a107;
   wire signed [7:0] a117;
   wire signed [7:0] a108;
   wire signed [7:0] tm15;
   wire signed [7:0] a109;
   wire signed [7:0] a118;
   wire signed [7:0] a110;
   wire signed [7:0] Y2;
   wire signed [7:0] a111;
   wire signed [7:0] a112;
   wire signed [7:0] Y3;
   reg signed [7:0] tm48;
   reg signed [7:0] tm49;
   reg signed [7:0] tm220;
   reg signed [7:0] tm221;
   reg signed [7:0] tm222;
   reg signed [7:0] tm223;
   reg signed [7:0] tm224;
   reg signed [7:0] tm225;
   reg signed [7:0] tm226;
   reg signed [7:0] tm227;
   reg signed [7:0] tm236;
   reg signed [7:0] tm237;
   reg signed [7:0] tm238;
   reg signed [7:0] tm239;
   reg signed [7:0] tm240;
   reg signed [7:0] tm241;
   reg signed [7:0] tm242;
   reg signed [7:0] tm243;
   reg signed [7:0] tm244;
   reg signed [7:0] tm245;
   reg signed [7:0] tm246;
   reg signed [7:0] tm247;
   reg signed [7:0] tm248;
   reg signed [7:0] tm249;


   assign a113 = X0;
   assign a102 = a113;
   assign Y0 = tm242;
   assign a116 = X1;
   assign a106 = a116;
   assign Y1 = tm249;
   assign a107 = tm14;
   assign a117 = X2;
   assign a109 = tm15;
   assign a118 = X3;

   D6 instD6inst0(.addr(i5[3:0]), .out(tm14), .clk(clk));

   D8 instD8inst0(.addr(i5[3:0]), .out(tm15), .clk(clk));

    multfix #(8, 2) m15226(.a(tm48), .b(tm223), .clk(clk), .q_sc(a108), .q_unsc(), .rst(reset));
    multfix #(8, 2) m15248(.a(tm49), .b(tm227), .clk(clk), .q_sc(a110), .q_unsc(), .rst(reset));
    subfxp #(8, 1) sub15254(.a(a108), .b(a110), .clk(clk), .q(Y2));
    multfix #(8, 2) m15265(.a(tm49), .b(tm223), .clk(clk), .q_sc(a111), .q_unsc(), .rst(reset));
    multfix #(8, 2) m15276(.a(tm48), .b(tm227), .clk(clk), .q_sc(a112), .q_unsc(), .rst(reset));
    addfxp #(8, 1) add15283(.a(a111), .b(a112), .clk(clk), .q(Y3));
   always @(posedge clk) begin
      if (reset == 1) begin
         tm48 <= 0;
         tm223 <= 0;
         tm49 <= 0;
         tm227 <= 0;
         tm49 <= 0;
         tm223 <= 0;
         tm48 <= 0;
         tm227 <= 0;
      end
      else begin
         i5 <= i5_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm48 <= a107;
         tm49 <= a109;
         tm220 <= a117;
         tm221 <= tm220;
         tm222 <= tm221;
         tm223 <= tm222;
         tm224 <= a118;
         tm225 <= tm224;
         tm226 <= tm225;
         tm227 <= tm226;
         tm236 <= a102;
         tm237 <= tm236;
         tm238 <= tm237;
         tm239 <= tm238;
         tm240 <= tm239;
         tm241 <= tm240;
         tm242 <= tm241;
         tm243 <= a106;
         tm244 <= tm243;
         tm245 <= tm244;
         tm246 <= tm245;
         tm247 <= tm246;
         tm248 <= tm247;
         tm249 <= tm248;
      end
   end
endmodule

module codeBlock15359(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [7:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_16745(.X(next), .Y(next_out), .clk(clk));


   wire signed [7:0] a69;
   wire signed [7:0] a70;
   wire signed [7:0] t45;
   wire signed [7:0] a71;
   wire signed [7:0] a72;
   wire signed [7:0] t46;
   wire signed [7:0] t47;
   wire signed [7:0] t48;
   wire signed [7:0] Y0;
   wire signed [7:0] Y1;
   wire signed [7:0] Y2;
   wire signed [7:0] Y3;


   assign a69 = X0;
   assign a70 = X2;
   assign a71 = X1;
   assign a72 = X3;
   assign Y0 = t45;
   assign Y1 = t46;
   assign Y2 = t47;
   assign Y3 = t48;

    addfxp #(8, 1) add15371(.a(a69), .b(a70), .clk(clk), .q(t45));
    addfxp #(8, 1) add15386(.a(a71), .b(a72), .clk(clk), .q(t46));
    subfxp #(8, 1) sub15400(.a(a69), .b(a70), .clk(clk), .q(t47));
    subfxp #(8, 1) sub15414(.a(a71), .b(a72), .clk(clk), .q(t48));
   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

module rc15439(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [15:0] t0;
   wire [15:0] s0;
   assign t0 = {X0, X1};
   wire [15:0] t1;
   wire [15:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[15:8];
   assign Y1 = s0[7:0];
   assign Y2 = s1[15:8];
   assign Y3 = s1[7:0];

   perm15437 instPerm16746(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module perm15437(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 32;
   parameter logDepth = 5;
   parameter width = 16;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[5] ^ addr0[0];
   assign inAddr0[0] = addr0[1];
   assign inAddr0[1] = addr0[2];
   assign inAddr0[2] = addr0[3];
   assign inAddr0[3] = addr0[4];
   assign inAddr0[4] = addr0[0];
   assign outBank0[0] = addr0b[5] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outAddr0[2] = addr0b[3];
   assign outAddr0[3] = addr0b[4];
   assign outAddr0[4] = addr0b[5];
   assign outBank_a0[0] = addr0c[5] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];
   assign outAddr_a0[2] = addr0c[3];
   assign outAddr_a0[3] = addr0c[4];
   assign outAddr_a0[4] = addr0c[5];

   assign inBank1[0] = addr1[5] ^ addr1[0];
   assign inAddr1[0] = addr1[1];
   assign inAddr1[1] = addr1[2];
   assign inAddr1[2] = addr1[3];
   assign inAddr1[3] = addr1[4];
   assign inAddr1[4] = addr1[0];
   assign outBank1[0] = addr1b[5] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outAddr1[2] = addr1b[3];
   assign outAddr1[3] = addr1b[4];
   assign outAddr1[4] = addr1b[5];
   assign outBank_a1[0] = addr1c[5] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];
   assign outAddr_a1[2] = addr1c[3];
   assign outAddr_a1[3] = addr1c[4];
   assign outAddr_a1[4] = addr1c[5];

   nextReg #(17, 5) nextReg_16751(.X(next), .Y(next0), .reset(reset), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_16754(.X(next0), .Y(next_out), .clk(clk));


   memArray64_15437 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 16)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 18)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 16) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 31) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 16)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[4];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[4];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[4];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray64_15437(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 32;
   parameter logDepth = 5;
   parameter width = 16;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   nextReg #(32, 5) nextReg_16759(.X(next), .Y(next0), .reset(reset), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule

module DirSum_15733(clk, reset, next, next_out,
      X0, Y0,
      X1, Y1,
      X2, Y2,
      X3, Y3);

   output next_out;
   input clk, reset, next;

   reg [4:0] i4;

   input [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   always @(posedge clk) begin
      if (reset == 1) begin
         i4 <= 0;
      end
      else begin
         if (next == 1)
            i4 <= 0;
         else if (i4 == 31)
            i4 <= 0;
         else
            i4 <= i4 + 1;
      end
   end

   codeBlock15441 codeBlockIsnt16764(.clk(clk), .reset(reset), .next_in(next), .next_out(next_out),
.i4_in(i4),
       .X0_in(X0), .Y0(Y0),
       .X1_in(X1), .Y1(Y1),
       .X2_in(X2), .Y2(Y2),
       .X3_in(X3), .Y3(Y3));

endmodule

module D2(addr, out, clk);
   input clk;
   output [7:0] out;
   reg [7:0] out, out2, out3;
   input [4:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 8'h40;
      1: out3 <= 8'h40;
      2: out3 <= 8'h3f;
      3: out3 <= 8'h3d;
      4: out3 <= 8'h3b;
      5: out3 <= 8'h38;
      6: out3 <= 8'h35;
      7: out3 <= 8'h31;
      8: out3 <= 8'h2d;
      9: out3 <= 8'h29;
      10: out3 <= 8'h24;
      11: out3 <= 8'h1e;
      12: out3 <= 8'h18;
      13: out3 <= 8'h13;
      14: out3 <= 8'hc;
      15: out3 <= 8'h6;
      16: out3 <= 8'h0;
      17: out3 <= 8'hfa;
      18: out3 <= 8'hf4;
      19: out3 <= 8'hed;
      20: out3 <= 8'he8;
      21: out3 <= 8'he2;
      22: out3 <= 8'hdc;
      23: out3 <= 8'hd7;
      24: out3 <= 8'hd3;
      25: out3 <= 8'hcf;
      26: out3 <= 8'hcb;
      27: out3 <= 8'hc8;
      28: out3 <= 8'hc5;
      29: out3 <= 8'hc3;
      30: out3 <= 8'hc1;
      31: out3 <= 8'hc0;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module D4(addr, out, clk);
   input clk;
   output [7:0] out;
   reg [7:0] out, out2, out3;
   input [4:0] addr;

   always @(posedge clk) begin
      out2 <= out3;
      out <= out2;
   case(addr)
      0: out3 <= 8'h0;
      1: out3 <= 8'hfa;
      2: out3 <= 8'hf4;
      3: out3 <= 8'hed;
      4: out3 <= 8'he8;
      5: out3 <= 8'he2;
      6: out3 <= 8'hdc;
      7: out3 <= 8'hd7;
      8: out3 <= 8'hd3;
      9: out3 <= 8'hcf;
      10: out3 <= 8'hcb;
      11: out3 <= 8'hc8;
      12: out3 <= 8'hc5;
      13: out3 <= 8'hc3;
      14: out3 <= 8'hc1;
      15: out3 <= 8'hc0;
      16: out3 <= 8'hc0;
      17: out3 <= 8'hc0;
      18: out3 <= 8'hc1;
      19: out3 <= 8'hc3;
      20: out3 <= 8'hc5;
      21: out3 <= 8'hc8;
      22: out3 <= 8'hcb;
      23: out3 <= 8'hcf;
      24: out3 <= 8'hd3;
      25: out3 <= 8'hd7;
      26: out3 <= 8'hdc;
      27: out3 <= 8'he2;
      28: out3 <= 8'he8;
      29: out3 <= 8'hed;
      30: out3 <= 8'hf4;
      31: out3 <= 8'hfa;
      default: out3 <= 0;
   endcase
   end
// synthesis attribute rom_style of out3 is "block"
endmodule



module codeBlock15441(clk, reset, next_in, next_out,
   i4_in,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;
   input [4:0] i4_in;
   reg [4:0] i4;

   input [7:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(7, 1) shiftFIFO_16767(.X(next), .Y(next_out), .clk(clk));


   wire signed [7:0] a53;
   wire signed [7:0] a42;
   wire signed [7:0] Y0;
   wire signed [7:0] a56;
   wire signed [7:0] a46;
   wire signed [7:0] Y1;
   wire signed [7:0] tm18;
   wire signed [7:0] a47;
   wire signed [7:0] a57;
   wire signed [7:0] a48;
   wire signed [7:0] tm19;
   wire signed [7:0] a49;
   wire signed [7:0] a58;
   wire signed [7:0] a50;
   wire signed [7:0] Y2;
   wire signed [7:0] a51;
   wire signed [7:0] a52;
   wire signed [7:0] Y3;
   reg signed [7:0] tm56;
   reg signed [7:0] tm57;
   reg signed [7:0] tm250;
   reg signed [7:0] tm251;
   reg signed [7:0] tm252;
   reg signed [7:0] tm253;
   reg signed [7:0] tm254;
   reg signed [7:0] tm255;
   reg signed [7:0] tm256;
   reg signed [7:0] tm257;
   reg signed [7:0] tm266;
   reg signed [7:0] tm267;
   reg signed [7:0] tm268;
   reg signed [7:0] tm269;
   reg signed [7:0] tm270;
   reg signed [7:0] tm271;
   reg signed [7:0] tm272;
   reg signed [7:0] tm273;
   reg signed [7:0] tm274;
   reg signed [7:0] tm275;
   reg signed [7:0] tm276;
   reg signed [7:0] tm277;
   reg signed [7:0] tm278;
   reg signed [7:0] tm279;


   assign a53 = X0;
   assign a42 = a53;
   assign Y0 = tm272;
   assign a56 = X1;
   assign a46 = a56;
   assign Y1 = tm279;
   assign a47 = tm18;
   assign a57 = X2;
   assign a49 = tm19;
   assign a58 = X3;

   D2 instD2inst0(.addr(i4[4:0]), .out(tm18), .clk(clk));

   D4 instD4inst0(.addr(i4[4:0]), .out(tm19), .clk(clk));

    multfix #(8, 2) m15539(.a(tm56), .b(tm253), .clk(clk), .q_sc(a48), .q_unsc(), .rst(reset));
    multfix #(8, 2) m15561(.a(tm57), .b(tm257), .clk(clk), .q_sc(a50), .q_unsc(), .rst(reset));
    subfxp #(8, 1) sub15567(.a(a48), .b(a50), .clk(clk), .q(Y2));
    multfix #(8, 2) m15578(.a(tm57), .b(tm253), .clk(clk), .q_sc(a51), .q_unsc(), .rst(reset));
    multfix #(8, 2) m15589(.a(tm56), .b(tm257), .clk(clk), .q_sc(a52), .q_unsc(), .rst(reset));
    addfxp #(8, 1) add15596(.a(a51), .b(a52), .clk(clk), .q(Y3));
   always @(posedge clk) begin
      if (reset == 1) begin
         tm56 <= 0;
         tm253 <= 0;
         tm57 <= 0;
         tm257 <= 0;
         tm57 <= 0;
         tm253 <= 0;
         tm56 <= 0;
         tm257 <= 0;
      end
      else begin
         i4 <= i4_in;
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
         tm56 <= a47;
         tm57 <= a49;
         tm250 <= a57;
         tm251 <= tm250;
         tm252 <= tm251;
         tm253 <= tm252;
         tm254 <= a58;
         tm255 <= tm254;
         tm256 <= tm255;
         tm257 <= tm256;
         tm266 <= a42;
         tm267 <= tm266;
         tm268 <= tm267;
         tm269 <= tm268;
         tm270 <= tm269;
         tm271 <= tm270;
         tm272 <= tm271;
         tm273 <= a46;
         tm274 <= tm273;
         tm275 <= tm274;
         tm276 <= tm275;
         tm277 <= tm276;
         tm278 <= tm277;
         tm279 <= tm278;
      end
   end
endmodule

module codeBlock15736(clk, reset, next_in, next_out,
   X0_in, Y0,
   X1_in, Y1,
   X2_in, Y2,
   X3_in, Y3);

   output next_out;
   input clk, reset, next_in;

   reg next;

   input [7:0] X0_in,
      X1_in,
      X2_in,
      X3_in;

   reg   [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   shiftRegFIFO #(1, 1) shiftFIFO_16770(.X(next), .Y(next_out), .clk(clk));


   wire signed [7:0] a9;
   wire signed [7:0] a10;
   wire signed [7:0] t21;
   wire signed [7:0] a11;
   wire signed [7:0] a12;
   wire signed [7:0] t22;
   wire signed [7:0] t23;
   wire signed [7:0] t24;
   wire signed [7:0] Y0;
   wire signed [7:0] Y1;
   wire signed [7:0] Y2;
   wire signed [7:0] Y3;


   assign a9 = X0;
   assign a10 = X2;
   assign a11 = X1;
   assign a12 = X3;
   assign Y0 = t21;
   assign Y1 = t22;
   assign Y2 = t23;
   assign Y3 = t24;

    addfxp #(8, 1) add15748(.a(a9), .b(a10), .clk(clk), .q(t21));
    addfxp #(8, 1) add15763(.a(a11), .b(a12), .clk(clk), .q(t22));
    subfxp #(8, 1) sub15777(.a(a9), .b(a10), .clk(clk), .q(t23));
    subfxp #(8, 1) sub15791(.a(a11), .b(a12), .clk(clk), .q(t24));
   always @(posedge clk) begin
      if (reset == 1) begin
      end
      else begin
         X0 <= X0_in;
         X1 <= X1_in;
         X2 <= X2_in;
         X3 <= X3_in;
         next <= next_in;
      end
   end
endmodule

module rc15816(clk, reset, next, next_out,
   X0, Y0,
   X1, Y1,
   X2, Y2,
   X3, Y3);

   output next_out;
   input clk, reset, next;

   input [7:0] X0,
      X1,
      X2,
      X3;

   output [7:0] Y0,
      Y1,
      Y2,
      Y3;

   wire [15:0] t0;
   wire [15:0] s0;
   assign t0 = {X0, X1};
   wire [15:0] t1;
   wire [15:0] s1;
   assign t1 = {X2, X3};
   assign Y0 = s0[15:8];
   assign Y1 = s0[7:0];
   assign Y2 = s1[15:8];
   assign Y3 = s1[7:0];

   perm15814 instPerm16771(.x0(t0), .y0(s0),
    .x1(t1), .y1(s1),
   .clk(clk), .next(next), .next_out(next_out), .reset(reset)
);



endmodule

module perm15814(clk, next, reset, next_out,
   x0, y0,
   x1, y1);
   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 32;
   parameter logDepth = 5;
   parameter width = 16;

   input [width-1:0]  x0;
   output [width-1:0]  y0;
   wire [width-1:0]  ybuff0;
   input [width-1:0]  x1;
   output [width-1:0]  y1;
   wire [width-1:0]  ybuff1;
   input 	      clk, next, reset;
   output 	     next_out;

   wire    	     next0;

   reg              inFlip0, outFlip0;
   reg              inActive, outActive;

   wire [logBanks-1:0] inBank0, outBank0;
   wire [logDepth-1:0] inAddr0, outAddr0;
   wire [logBanks-1:0] outBank_a0;
   wire [logDepth-1:0] outAddr_a0;
   wire [logDepth+logBanks-1:0] addr0, addr0b, addr0c;
   wire [logBanks-1:0] inBank1, outBank1;
   wire [logDepth-1:0] inAddr1, outAddr1;
   wire [logBanks-1:0] outBank_a1;
   wire [logDepth-1:0] outAddr_a1;
   wire [logDepth+logBanks-1:0] addr1, addr1b, addr1c;


   reg [logDepth-1:0]  inCount, outCount, outCount_d, outCount_dd, outCount_for_rd_addr, outCount_for_rd_data;  

   assign    addr0 = {inCount, 1'd0};
   assign    addr0b = {outCount, 1'd0};
   assign    addr0c = {outCount_for_rd_addr, 1'd0};
   assign    addr1 = {inCount, 1'd1};
   assign    addr1b = {outCount, 1'd1};
   assign    addr1c = {outCount_for_rd_addr, 1'd1};
    wire [width+logDepth-1:0] w_0_0, w_0_1, w_1_0, w_1_1;

    reg [width-1:0] z_0_0;
    reg [width-1:0] z_0_1;
    wire [width-1:0] z_1_0, z_1_1;

    wire [logDepth-1:0] u_0_0, u_0_1, u_1_0, u_1_1;

    always @(posedge clk) begin
    end

   assign inBank0[0] = addr0[1] ^ addr0[0];
   assign inAddr0[0] = addr0[2];
   assign inAddr0[1] = addr0[3];
   assign inAddr0[2] = addr0[4];
   assign inAddr0[3] = addr0[5];
   assign inAddr0[4] = addr0[0];
   assign outBank0[0] = addr0b[5] ^ addr0b[0];
   assign outAddr0[0] = addr0b[1];
   assign outAddr0[1] = addr0b[2];
   assign outAddr0[2] = addr0b[3];
   assign outAddr0[3] = addr0b[4];
   assign outAddr0[4] = addr0b[5];
   assign outBank_a0[0] = addr0c[5] ^ addr0c[0];
   assign outAddr_a0[0] = addr0c[1];
   assign outAddr_a0[1] = addr0c[2];
   assign outAddr_a0[2] = addr0c[3];
   assign outAddr_a0[3] = addr0c[4];
   assign outAddr_a0[4] = addr0c[5];

   assign inBank1[0] = addr1[1] ^ addr1[0];
   assign inAddr1[0] = addr1[2];
   assign inAddr1[1] = addr1[3];
   assign inAddr1[2] = addr1[4];
   assign inAddr1[3] = addr1[5];
   assign inAddr1[4] = addr1[0];
   assign outBank1[0] = addr1b[5] ^ addr1b[0];
   assign outAddr1[0] = addr1b[1];
   assign outAddr1[1] = addr1b[2];
   assign outAddr1[2] = addr1b[3];
   assign outAddr1[3] = addr1b[4];
   assign outAddr1[4] = addr1b[5];
   assign outBank_a1[0] = addr1c[5] ^ addr1c[0];
   assign outAddr_a1[0] = addr1c[1];
   assign outAddr_a1[1] = addr1c[2];
   assign outAddr_a1[2] = addr1c[3];
   assign outAddr_a1[3] = addr1c[4];
   assign outAddr_a1[4] = addr1c[5];

   nextReg #(17, 5) nextReg_16776(.X(next), .Y(next0), .reset(reset), .clk(clk));


   shiftRegFIFO #(2, 1) shiftFIFO_16779(.X(next0), .Y(next_out), .clk(clk));


   memArray64_15814 #(numBanks, logBanks, depth, logDepth, width)
     memSys(.inFlip(inFlip0), .outFlip(outFlip0), .next(next), .reset(reset),
        .x0(w_1_0[width+logDepth-1:logDepth]), .y0(ybuff0),
        .inAddr0(w_1_0[logDepth-1:0]),
        .outAddr0(u_1_0), 
        .x1(w_1_1[width+logDepth-1:logDepth]), .y1(ybuff1),
        .inAddr1(w_1_1[logDepth-1:0]),
        .outAddr1(u_1_1), 
        .clk(clk));

   always @(posedge clk) begin
      if (reset == 1) begin
      z_0_0 <= 0;
      z_0_1 <= 0;
         inFlip0 <= 0; outFlip0 <= 1; outCount <= 0; inCount <= 0;
        outCount_for_rd_addr <= 0;
        outCount_for_rd_data <= 0;
      end
      else begin
          outCount_d <= outCount;
          outCount_dd <= outCount_d;
         if (inCount == 16)
            outCount_for_rd_addr <= 0;
         else
            outCount_for_rd_addr <= outCount_for_rd_addr+1;
         if (inCount == 18)
            outCount_for_rd_data <= 0;
         else
            outCount_for_rd_data <= outCount_for_rd_data+1;
      z_0_0 <= ybuff0;
      z_0_1 <= ybuff1;
         if (inCount == 16) begin
            outFlip0 <= ~outFlip0;
            outCount <= 0;
         end
         else
            outCount <= outCount+1;
         if (inCount == 31) begin
            inFlip0 <= ~inFlip0;
         end
         if (next == 1) begin
            if (inCount >= 16)
               inFlip0 <= ~inFlip0;
            inCount <= 0;
         end
         else
            inCount <= inCount + 1;
      end
   end
    assign w_0_0 = {x0, inAddr0};
    assign w_0_1 = {x1, inAddr1};
    assign y0 = z_1_0;
    assign y1 = z_1_1;
    assign u_0_0 = outAddr_a0;
    assign u_0_1 = outAddr_a1;
    wire wr_ctrl_st_0;
    assign wr_ctrl_st_0 = inCount[0];

    switch #(logDepth+width) in_sw_0_0(.x0(w_0_0), .x1(w_0_1), .y0(w_1_0), .y1(w_1_1), .ctrl(wr_ctrl_st_0));
    wire rdd_ctrl_st_0;
    assign rdd_ctrl_st_0 = outCount_for_rd_data[4];

    switch #(width) out_sw_0_0(.x0(z_0_0), .x1(z_0_1), .y0(z_1_0), .y1(z_1_1), .ctrl(rdd_ctrl_st_0));
    wire rda_ctrl_st_0;
    assign rda_ctrl_st_0 = outCount_for_rd_addr[4];

    switch #(logDepth) rdaddr_sw_0_0(.x0(u_0_0), .x1(u_0_1), .y0(u_1_0), .y1(u_1_1), .ctrl(rda_ctrl_st_0));
endmodule

module memArray64_15814(next, reset,
                x0, y0,
                inAddr0,
                outAddr0,
                x1, y1,
                inAddr1,
                outAddr1,
                clk, inFlip, outFlip);

   parameter numBanks = 2;
   parameter logBanks = 1;
   parameter depth = 32;
   parameter logDepth = 5;
   parameter width = 16;
         
   input     clk, next, reset;
   input    inFlip, outFlip;
   wire    next0;
   
   input [width-1:0]   x0;
   output [width-1:0]  y0;
   input [logDepth-1:0] inAddr0, outAddr0;
   input [width-1:0]   x1;
   output [width-1:0]  y1;
   input [logDepth-1:0] inAddr1, outAddr1;
   nextReg #(32, 5) nextReg_16784(.X(next), .Y(next0), .reset(reset), .clk(clk));


   memMod #(depth*2, width, logDepth+1) 
     memMod0(.in(x0), .out(y0), .inAddr({inFlip, inAddr0}),
	   .outAddr({outFlip, outAddr0}), .writeSel(1'b1), .clk(clk));   
   memMod #(depth*2, width, logDepth+1) 
     memMod1(.in(x1), .out(y1), .inAddr({inFlip, inAddr1}),
	   .outAddr({outFlip, outAddr1}), .writeSel(1'b1), .clk(clk));   
endmodule


						module multfix(clk, rst, a, b, q_sc, q_unsc);
						   parameter WIDTH=35, CYCLES=6;

						   input signed [WIDTH-1:0]    a,b;
						   output [WIDTH-1:0]          q_sc;
						   output [WIDTH-1:0]              q_unsc;

						   input                       clk, rst;
						   
						   reg signed [2*WIDTH-1:0]    q[CYCLES-1:0];
						   wire signed [2*WIDTH-1:0]   res;   
						   integer                     i;

						   assign                      res = q[CYCLES-1];   
						   
						   assign                      q_unsc = res[WIDTH-1:0];
						   assign                      q_sc = {res[2*WIDTH-1], res[2*WIDTH-4:WIDTH-2]};
						      
						   always @(posedge clk) begin
						      q[0] <= a * b;
						      for (i = 1; i < CYCLES; i=i+1) begin
						         q[i] <= q[i-1];
						      end
						   end
						                  
						endmodule 
module addfxp(a, b, q, clk);

   parameter width = 16, cycles=1;
   
   input signed [width-1:0]  a, b;
   input                     clk;   
   output signed [width-1:0] q;
   reg signed [width-1:0]    res[cycles-1:0];

   assign                    q = res[cycles-1];
   
   integer                   i;   
   
   always @(posedge clk) begin
     res[0] <= a+b;
      for (i=1; i < cycles; i = i+1)
        res[i] <= res[i-1];
      
   end
   
endmodule

module subfxp(a, b, q, clk);

   parameter width = 16, cycles=1;
   
   input signed [width-1:0]  a, b;
   input                     clk;   
   output signed [width-1:0] q;
   reg signed [width-1:0]    res[cycles-1:0];

   assign                    q = res[cycles-1];
   
   integer                   i;   
   
   always @(posedge clk) begin
     res[0] <= a-b;
      for (i=1; i < cycles; i = i+1)
        res[i] <= res[i-1];
      
   end
  
endmodule
